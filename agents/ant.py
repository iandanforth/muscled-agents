"""
Ant

Learn to control your muscles to make forward progress!

Control Signals

The action space for an ant is continuous control over 16 muscles. For
each of four legs there are four muscles. One leg extensor, one leg flexor,
and two hip muscles which move the leg left and right (or forward and back
depending on your perspective.)

Gym Environment

The `step` method takes an array of 16 values which represent the input to
the fatigable muscle model for each muscle.

PyMuscle Model

The range of valid input values for the muscle model is 0.0 to 1.0.

For example if you send an input value of 0.1 to the muscle model a small number
of weak motor units will be recruited and a small fraction of the total possible
force will be generated by the muscle. If, however, you use an value of 0.95 then
all or nearly all the motor units will be recruited and the muscle will produce
maximal voluntary output.

Output values are normalized by the maximum voluntary force the muscle can
produce. That value is a function of its instantiation characteristics. Output
values will thus be between 0.0 and 1.0.

PyMuscle Fatigue

After use muscles produce less force for the same level of input. So if you
were to send an input signal which recruited all motor units in a muscle
constantly for several seconds the output the model will return will rapidly
decrease. A period of light or no use is required for the muscle to recover.

MuJoCo Model

Each tendon actuator is control limited to the range [-3.0, 0.0]. When a
General actuator is tied to a Tendon in MuJoCo negative values are the
equivalent of contractions. Muscles cannot produce force in extension so no
positive non-zero values are allowed.

The expected input range is [-1.0, 0.0] which is the equivalent of voluntary
force. However real muscles can actually produce 3x voluntary force under
certain circumstances so we reserve that here for future use.

Actuators have a `gainprm` which scales this input value. This is tuned to
a value of 200 to work with the mass of the ant and the resistances of opposing
tendons.


"""
import math
import numpy as np
import muscledagents
import re
import pickle
import time
import mujoco_py

import gym
from gym import logger
from mujoco_py import MujocoException


def load_action_log(filepath):
    cleanlines = []
    with open(filepath, 'r') as fh:
        cleanline = []
        close_count = 0
        for line in fh:
            for char in line:
                if close_count == 2:
                    str_line = "".join(cleanline)
                    str_line = re.sub(' +', ' ', str_line)
                    str_line = str_line.strip()
                    str_line = re.sub('\n', '', str_line)
                    cleanlines.append(str_line)
                    cleanline = []
                    close_count = 0
                if char == "[":
                    continue
                if char == "]":
                    close_count += 1
                    continue
                cleanline.append(char)

    # Further cleaning
    clean_arrays = []
    for line in cleanlines:
        arr = line.split(" ")
        arr = [float(x) for x in arr]
        clean_arrays.append(arr)

    return clean_arrays


def main():

    # Load a standard ant
    env = gym.make("MuscledAnt-v0")
    env.reset()

    print("Observation Space Dims", env.observation_space.shape)
    print("Action Space Dims", env.action_space.shape)

    input_size = env.observation_space.shape[0]
    action_size = env.action_space.shape[0]

    # actions = pickle.load(open("crash-actions-1547839500.p", "rb"))
    # while True:
    #     for action in actions:
    #         env.step(action)
    #         env.render()
    #     env.reset()

    # quit()

    # actions = load_action_log("crash.txt")
    # for action in actions:
    #     env.step(action)
    #     env.render()

    # quit()

    # ep_counter = 0
    # action_list = []
    # while True:
    #     action = np.random.rand(16)
    #     action_list.append(action)
    #     try:
    #         ob, reward, done, extras = env.step(action)
    #         # env.render()
    #     except MujocoException as e:
    #         filename = "crash-actions-{}.p".format(int(time.time()))
    #         print("Dumping action list to {}".format(filename))
    #         pickle.dump(action_list, open(filename, 'wb'))
    #         import web_pdb; web_pdb.set_trace()
    #     if done:
    #         print("Episode {}".format(ep_counter))
    #         ep_counter += 1
    #         action_list = []
    #         env.reset()

    # Set up the simulation parameters
    sim_duration = 360  # seconds
    frames_per_second = 50
    step_size = 1 / frames_per_second
    total_steps = int(sim_duration / step_size)

    # Step according to a complex pattern
    # https://www.desmos.com/calculator/c0uq1mul2a
    action = [0.0] * action_size
    for i in range(total_steps):
        action[1] = ((math.sin(i / 25) + 1) / 2)
        action[5] = ((math.sin(i / 35) + 1) / 2)
        action[9] = ((math.sin(i / 45) + 1) / 2)
        action[13] = ((math.sin(i / 55) + 1) / 2)
        ob, reward, done, extras = env.step(action)
        env.render()

if __name__ == '__main__':
    main()
